\documentclass{article}
\usepackage[T1]{fontenc}
\title{\Huge{Semi-automatic sequences}}
\author{Jeroen F. J. Laros}
\date{\today}

% The package for the automata.
\usepackage{/home/jeroen/studie/dw/graphs/graphs}

% Mathematical symbols and stuff.
\usepackage{amsfonts, amssymb, amsthm}

% No weird spaces after a '.'
\frenchspacing

% Do not indent on a new paragraph.
\setlength{\parindent}{0pt}

\renewcommand{\qedsymbol}{$\blacksquare$}
\newcommand{\monoit}[1]{\texttt{\textit{#1}}}
\newcommand{\spaces}{\begin{picture}(9,0)(0,0)\end{picture}}

\newtheorem{theorem}{Theorem}[subsection]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}

\theoremstyle{definition}
\newtheorem{example}[theorem]{Example}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{conjecture}[theorem]{Conjecture}

\renewcommand{\thefigure}{\thesubsection.\arabic{figure}}

\begin{document}
\maketitle
\newpage

\tableofcontents
\newpage

\section{Introduction}
The Fibonacci substitution caught our interest because it defines a numeration
system and we wondered if there are other substitutions having the same 
property. We present a class of substitutions for which this property holds.

\section{Definitions}
First we shall give a couple of definitions which we will use in this document.

\begin{definition}[Substitution] \label{def:substitution}
A \emph{substitution} $\sigma$ is a function from an alphabet $\mathcal{A}$ to 
$\mathcal{A}^* - \{\epsilon\}$ of nonempty finite words on $\mathcal{A}$. It
extends to a morphism of $\mathcal{A}^*$ by concatenation. So 
$\sigma(w w') = \sigma(w) \sigma(w')$ and $\sigma(\epsilon) = \epsilon$.
\end{definition}

\begin{definition}[$n$-word] \label{def:n-word}
An \emph{$n$-word} of a substitution $\sigma$ is the unique word 
$\sigma^n(\iota)$, $\iota \in \mathcal{A}$ being the initial letter.

\begin{definition}[Fixed point] \label{def:fixed_point}
A \emph{fixed point} of a substitution $\sigma$ is an infinite sequence $u$ 
with $\sigma(u) = u$.
\end{definition}

The construction of a fixed point goes as follows:

Let $\sigma$ be a substitution over an alphabet $\mathcal{A}$. Define 
$\sigma_i: \mathcal{A \rightarrow A}$, which sends the letter $a$ to the 
$(i + 1)$-th letter of $\sigma(a)$ for all $0 \le i \le j$. Let $j$ be the 
index of the last letter of $\sigma(a)$. Hence 
$\sigma = \sigma_0 \ldots \sigma_{j - 1}$.

Let $\sigma^0 = a$ and let $\sigma^1 = a \cdot w^1$, with 
$w^1 = \sigma_1(a) ... \sigma_{j - 1}(a)$. Let $w^n = \sigma(w^{n - 1})$ and 
let $\sigma^n = \sigma^{n - 1} \cdot \sigma(w^{n - 1})$.

The fixed point $u = \sigma^\infty$.

\begin{definition}[Automaton] \label{def:automaton}
An \emph{automaton} $A = \{\mathcal{S}, \Delta, \delta, I, F, Y, \varphi\}$ in 
which:
\begin{itemize}
\item $\mathcal{S}$ is the finite set of \emph{states}.
\item $\Delta$ is the finite set of \emph{labels}.
\item $\delta \subseteq \mathcal{S} \times \Delta \times \mathcal{S}$ is the
      collection of \emph{transitions}.
\item $I \subseteq \mathcal{S}$ is the collection of \emph{initial states}.
\item $I \subseteq \mathcal{S}$ is the collection of \emph{final states}.
\item $Y$ the output alphabet.
\item $\varphi$ is a function from $\mathcal{S}$ to $Y$.
\end{itemize}
\end{definition}

We represent an automaton by a directed graph with a set of vertices
$\mathcal{S}$ called \emph{states}, a set of edges $\delta$ called
\emph{transitions} and specially marked subsets of states $I$ and $F$, the
\emph{initial} and \emph{final} states.

All through this document we shall take $I = \{\iota\}$ as the only initial
state and $F = \mathcal{S}$ as the collection of final states and we shall
take $\Delta \subset \mathbb{N}$.

Furthermore we shall usually take $Y = \mathcal{S}$ and $\varphi = Id$ as the
output alphabet and the exit map.

Note that the output function applies to the states and not to the labels.
\end{definition}

\begin{definition}[Regular language] \label{def:regular_language}
A language is \emph{regular} if and only if it is accepted by a finite 
automaton.
\end{definition}

\begin{definition}[Regular expression] \label{def:regular_expression}
Let $\Sigma$ be an alphabet. Then a \emph{regular expression} $E$ over $\Sigma$
is defined recursively as one of the following types:
\begin{itemize}
\item $\varnothing$.
\item $\epsilon$.
\item $a$, where $a \in \Sigma$.
\item $(E_1 \cup E_2)$, where $E_1$ and $E_2$ are regular expressions and the
      $\cup$ operator denotes a union.
\item $(E_1 \cdot E_2)$, where $E_1$ and $E_2$ are regular expressions and the
      $\cdot$ operator denotes concatenation.
\end{itemize}
\end{definition}

From Definition \ref{def:regular_expression} we can extract some other useful
features.
\begin{itemize}
\item $E^*$, where $E$ is a regular expression and the $^*$ operator denotes the
      union of all powers of $E$ ($K^* = \cup_{n \in \mathbb{N}}K^n$).
\item $E^+$, where is an abbreviation for $E \cdot E^*$.
\end{itemize}

We usually omit the $\cdot$ in a regular expression. The $\cup$ is sometimes
written as `+' or `,'.

Note that a regular expression must be of finite length, if it is not, it
defines an infinite automaton.

\begin{definition}[$k^\mathrm{max}$] \label{def:k-max}
Let $\Delta \subset \mathbb{N}$ be a finite sequence of consecutive integers, 
the collection of labels. Define $k^\mathrm{max} = |\Delta| - 1$.

Or equivalently let $\sigma$ be a substitution, define $k^\mathrm{max}$ as
the length of the largest image in $\sigma - 1$.
\end{definition}

\begin{definition}[Numeration system] \label{def:numeration_system}
In general a \emph{numeration system} is a strictly increasing sequence 
$U = (U_n)_{n \in \mathbb{N}}$ such that
\begin{itemize}
\item $U_0 = 1$ (to represent all $n \in \mathbb{N}$),
\item $\mathrm{sup}\frac{U_{n + 1}}{U_n} < \infty$ (to have a finite alphabet 
      of digits).
\item the sequence $a_k a_{k - 1} \ldots a_0$ must represent the integer
$n = \sum_{i = k}^0 a_i U_i$ for all $n \in \mathbb{N}$.
\end{itemize}
\end{definition}

It is quite natural to express the expansion of $U_i$ as
$1\underbrace{00\ldots0}_i$. 

In general more than one expansion can be found for an integer.

\begin{definition}[Full numeration system] \label{def:full_numeration_system}
A \emph{full numeration system} is a numeration system that has one extra
property. 
\begin{itemize}
\item for each expansion $A = a_k a_{k - 1} \ldots a_0$ and 
$B = b_k b_{k - 1} \ldots b_0$, the sum of $A + B$ equals 
$a_k + b_k a_{k - 1} + b_{k - 1} \ldots a_0 + b_0$ as long as the sum of 
$a_i + b_i \le U_i$
\end{itemize}
\end{definition}

\section{Equivalence between substitutions and automata}
\subsection{Substitutions in general}
A substitution $\sigma$ on an alphabet $\mathcal{A}$ defines an automaton in 
the following way:
\begin{itemize}
\item Let the collection of states $\mathcal{S} = \mathcal{A}$.
\item Add a transition from state $a$ to state $b$ ($a,b \in \mathcal{S}$) 
labeled $i$ if $b$ occurs in $\sigma(a)$ at position ($i$ + 1).
\item Let $\iota$ be the initial state.
\item Let all states in $\mathcal{S}$ be final states.
\end{itemize}

The automaton in turn defines a regular language.
\begin{lemma}[Automata and substitutions] \label{lem:automata_substitutions}
Let $\sigma$ be a substitution which is in bijection with an automaton $A$ and
let $\mathcal{L}(A)$ be the language of the automaton. Then $\sigma^n(\iota)_i$
is the state the automaton will be in after it is fed with the $i$-th word 
of length $n$ of its input language.
\end{lemma}

\begin{proof}
If we write the automaton as a tree, the equivalence is easy to see. We find 
$\sigma^n$ by reading all states at depth $n$ in the tree. The densification 
of the tree is equivalent to the construction of an $n$-word by the definition
of the $n$-word.
\end{proof}

\begin{example} \label{ex:automata_substitutions}
In figure \ref{fig:automata_substitutions} we see an automaton $A$ in bijection
with a substitution $\sigma$.

% Picture of automaton. {{{1
\begin{figure}[p]
\vbox{
\ \\
\ \\
\begin{eqnarray*}
\spaces
\sigma: \left\{ \begin{array}{lll}
a &\rightarrow& ba\\
b &\rightarrow& cb\\
c &\rightarrow& b
\end{array} \right.
\end{eqnarray*}
\begin{graph}(0, 0)(-4, -1)
  \graphnodecolour{1}
  \graphnodesize{1}
  \roundnode{s1}(-2, 0) \nodetext{s1}(0, 0){$a$}
  \roundnode{s2}(0, 0)  \nodetext{s2}(0, 0){$b$}
  \roundnode{s3}(2, 0)  \nodetext{s3}(0, 0){$c$}

  \diredge{s1}{s2} \edgetext{s1}{s2}{0}
  \dirloopedge{s1}{50}(-1, 0) \freetext(-3.6, 0){1}
  \dirbow{s2}{s3}{.2} \bowtext{s2}{s3}{.2}{0}
  \dirloopedge{s2}{50}(0, 1) \freetext(0, 1.6){1}
  \dirbow{s3}{s2}{.2} \bowtext{s3}{s2}{.2}{0}

  \freetext(-2, -0.7){$\Uparrow$}
\end{graph}}
\caption{An automaton in bijection with substitution $\sigma$}
\label{fig:automata_substitutions}
\end{figure}
%}}}1
When we write $A$ as a tree, the automaton does not change, for it still
accepts the same input language.

% Picture of tree automaton. {{{1
\begin{figure}[p]
\begin{graph}(0, 7.5)(-4, -2.5)
  \graphnodecolour{1}
  \graphnodesize{1}
  \roundnode{s1}(0, 4) \nodetext{s1}(0, 0){$a$} % level 0
  \freetext(6.02, 4){$\sigma^0(a) = a$}

  \roundnode{s2}(-2, 2)  \nodetext{s2}(0, 0){$b$} % level 1
  \roundnode{s3}(2, 2)  \nodetext{s3}(0, 0){$a$}
  \freetext(6.1, 2){$\sigma^1(a) = ba$}

  \roundnode{s4}(-3, 0)  \nodetext{s4}(0, 0){$c$} % level 2
  \roundnode{s5}(-1, 0)  \nodetext{s5}(0, 0){$b$}
  \roundnode{s6}(1, 0)  \nodetext{s6}(0, 0){$b$}
  \roundnode{s7}(3, 0)  \nodetext{s7}(0, 0){$a$}
  \freetext(6.25, 0){$\sigma^2(a) = cbba$}

  \roundnode{s8}(-3, -2)  \nodetext{s8}(0, 0){$b$} % level 3
  \roundnode{s9}(-1.5, -2)  \nodetext{s9}(0, 0){$c$}
  \roundnode{s10}(-0.5, -2) \nodetext{s10}(0, 0){$b$}

  \roundnode{s11}(0.5, -2)  \nodetext{s11}(0, 0){$c$}
  \roundnode{s12}(1.5, -2)  \nodetext{s12}(0, 0){$b$}
  \roundnode{s13}(2.5, -2)  \nodetext{s13}(0, 0){$b$}
  \roundnode{s14}(3.5, -2)  \nodetext{s14}(0, 0){$a$}
  \freetext(6.48, -2){$\sigma^3(a) = bcbcbba$}

  \diredge{s1}{s2} \edgetext{s1}{s2}{0}
  \diredge{s1}{s3} \edgetext{s1}{s3}{1}

  \diredge{s2}{s4} \edgetext{s2}{s4}{0}
  \diredge{s2}{s5} \edgetext{s2}{s5}{1}
  \diredge{s3}{s6} \edgetext{s3}{s6}{0}
  \diredge{s3}{s7} \edgetext{s3}{s7}{1}

  \diredge{s4}{s8} \edgetext{s4}{s8}{0}
  \diredge{s5}{s9} \edgetext{s5}{s9}{0}
  \diredge{s5}{s10} \edgetext{s5}{s10}{1}
  \diredge{s6}{s11} \edgetext{s6}{s11}{0}
  \diredge{s6}{s12} \edgetext{s6}{s12}{1}
  \diredge{s7}{s13} \edgetext{s7}{s13}{0}
  \diredge{s7}{s14} \edgetext{s7}{s14}{1}

  \freetext(0, 4.7){$\Downarrow$}
\end{graph}
\caption{A tree automaton in bijection with $\sigma$}
\label{fig:automata_tree_substitutions}
\end{figure}
%}}}1
The language accepted by both automata is 
$1^* + (1^* 0 (1 + 00)^* (0 + \epsilon))$. The first few elements of this
language are:
\begin{displaymath}
\mathcal{L}(A) = \{\underbrace{\epsilon,}_0
\underbrace{0, 1,}_1
\underbrace{00, 01, 10, 11,}_ 2
\underbrace{000, 010, 011, 100, 101, 110, 111,}_3 \ldots\}
\end{displaymath}
\end{example}

\subsection{Substitutions with fixed points} 
Of course lemma \ref{lem:automata_substitutions} is also valid for 
substitutions with a fixed point. The importance of a fixed point in a 
substitution will be clear now. For if we have a fixed point, the resulting 
automaton will accept leading zeroes in its input language. This is one of the 
conditions to make a numeration system. From now on we shall only look at 
substitutions with a fixed point. We shall also ignore words in 
$\mathcal{L}(A)$ with leading zeroes.

\begin{corollary}[Automata and substitutions with a fixed point] 
\label{cor:automata_substitutions_fixed_point}
Let $\sigma$ be a substitution which is in bijection with an automaton
$A$, let $u$ be the fixed point of the substitution and let $\mathcal{L}(A)$ 
be the language of the automaton. Then $u_i$ is the state the automaton 
will be in after it is fed with the $i$-th word of its input language.
\end{corollary}

\begin{proof}
This follows directly from lemma \ref{lem:automata_substitutions}.
\end{proof}

Note that the path leading to the $i$-th state (from the left) at depth $n$ 
is the $i$-th word of the language $\mathcal{L}(A)$, this is always true 
because of the recurrent nature of the tree.

\begin{example}
% Picture of automaton. {{{1
\begin{figure}[p]
\vbox{
\ \\
\ \\
\begin{eqnarray*}
\spaces
\sigma: \left\{ \begin{array}{lll}
a &\rightarrow& ab\\
b &\rightarrow& cb\\
c &\rightarrow& b
\end{array} \right.
\end{eqnarray*}
\begin{graph}(0, 0)(-4, -1)
  \graphnodecolour{1}
  \graphnodesize{1}
  \roundnode{s1}(-2, 0) \nodetext{s1}(0, 0){$a$}
  \roundnode{s2}(0, 0)  \nodetext{s2}(0, 0){$b$}
  \roundnode{s3}(2, 0)  \nodetext{s3}(0, 0){$c$}

  \dirloopedge{s1}{50}(-1, 0) \freetext(-3.6, 0){0}
  \diredge{s1}{s2} \edgetext{s1}{s2}{1}
  \dirbow{s2}{s3}{.2} \bowtext{s2}{s3}{.2}{0}
  \dirloopedge{s2}{50}(0, 1) \freetext(0, 1.6){1}
  \dirbow{s3}{s2}{.2} \bowtext{s3}{s2}{.2}{0}

  \freetext(-2, -0.7){$\Uparrow$}
\end{graph}}
\caption{An automaton with a fixed point}
\label{fig:automata_fixpoint_substitutions}
\end{figure}
%}}}1
The fixed point of $\sigma$ shown in figures 
\ref{fig:automata_fixpoint_substitutions} and 
\ref{fig:automata_tree_fixpoint_substitutions} with $a$ as the initial letter 
is:\\
\\
\monoit{u = abcbbcbcbbcbbcbcbbcbcbbcbbcbcbbcbbcbcbbcbcbbcbbcbcbbc\ldots}\\
\\
And\\
\\
$\mathcal{L}(A) = \{\epsilon, 0, 1, 10, 11, 100, 110, 111, 1000, 1001, 1100, 
1110, 1111, 10000, \ldots\}$

% Picture of tree automaton. {{{1
\begin{figure}[p]
\begin{graph}(0, 7.5)(-4, -2.5)
  \graphnodecolour{1}
  \graphnodesize{1}
  \roundnode{s1}(0, 4) \nodetext{s1}(0, 0){$a$} % level 0
  \freetext(6.02, 4){$\sigma^0 = a$}

  \roundnode{s2}(-2, 2)  \nodetext{s2}(0, 0){$a$} % level 1
  \roundnode{s3}(2, 2)  \nodetext{s3}(0, 0){$b$}
  \freetext(6.1, 2){$\sigma^1 = ab$}

  \roundnode{s4}(-3, 0)  \nodetext{s4}(0, 0){$a$} % level 2
  \roundnode{s5}(-1, 0)  \nodetext{s5}(0, 0){$b$}
  \roundnode{s6}(1, 0)  \nodetext{s6}(0, 0){$c$}
  \roundnode{s7}(3, 0)  \nodetext{s7}(0, 0){$b$}
  \freetext(6.25, 0){$\sigma^2 = abcb$}

  \roundnode{s8}(-3.5, -2)  \nodetext{s8}(0, 0){$a$} % level 3
  \roundnode{s9}(-2.5, -2)  \nodetext{s9}(0, 0){$b$}
  \roundnode{s10}(-1.5, -2) \nodetext{s10}(0, 0){$c$}
  \roundnode{s11}(-0.5, -2)  \nodetext{s11}(0, 0){$b$}
  \roundnode{s12}(1, -2)  \nodetext{s12}(0, 0){$b$}
  \roundnode{s13}(2.5, -2)  \nodetext{s13}(0, 0){$c$}
  \roundnode{s14}(3.5, -2)  \nodetext{s14}(0, 0){$b$}
  \freetext(6.48, -2){$\sigma^3 = abcbbcb$}

  \diredge{s1}{s2} \edgetext{s1}{s2}{0}
  \diredge{s1}{s3} \edgetext{s1}{s3}{1}
  
  \diredge{s2}{s4} \edgetext{s2}{s4}{0}
  \diredge{s2}{s5} \edgetext{s2}{s5}{1}
  \diredge{s3}{s6} \edgetext{s3}{s6}{0}
  \diredge{s3}{s7} \edgetext{s3}{s7}{1}

  \diredge{s4}{s8} \edgetext{s4}{s8}{0}
  \diredge{s4}{s9} \edgetext{s4}{s9}{1}
  \diredge{s5}{s10} \edgetext{s5}{s10}{0}
  \diredge{s5}{s11} \edgetext{s5}{s11}{1}
  \diredge{s6}{s12} \edgetext{s6}{s12}{0}
  \diredge{s7}{s13} \edgetext{s7}{s13}{0}
  \diredge{s7}{s14} \edgetext{s7}{s14}{1}

  \freetext(0, 4.7){$\Downarrow$}
\end{graph}
\caption{A tree automaton with a fixed point}
\label{fig:automata_tree_fixpoint_substitutions}
\end{figure}
%}}}1
\end{example}

\section{Semi-automatism}
Although corollary \ref{cor:automata_substitutions_fixed_point} is valid for 
all automata that are in bijection with a substitution which have a fixed point
(that means a fairly large group of automata), it is not as useful as it might 
seem at first glance. The problem is that in general we can not give the $n$-th
word of a language $\mathcal{L}$ a priory.

However, there is an obvious class of automata for which we can give the $n$-th
word, the so-called $k$-automata. In this class each letter has a substitution
word of length $k$. For this class of automata the $n$-th word of its input 
language is the $k$-base expansion of $n$.

There are also some non-$k$-automata for which we can describe the $n$-th word 
without much calculation. This class has the property that we can define a 
numeration system in which the expansion of $n$ is the $n$-th word of 
$\mathcal{L}(A)$.

\subsection{The Fibonacci substitution}
The Fibonacci substitution and its automaton can be seen in figure 
\ref{fig:fibonacci}.

% Picture of Fibonacci automaton. {{{1
\begin{figure}[p]
\vbox{
\begin{eqnarray*}
\spaces
\sigma: \left\{ \begin{array}{lll}
a &\rightarrow& ab\\
b &\rightarrow& a
\end{array} \right.
\end{eqnarray*}
\begin{graph}(0, 1)(-4, -1.75)
  \graphnodecolour{1}
  \graphnodesize{1}
  \roundnode{s1}(-2, 0) \nodetext{s1}(0, 0){$a$}
  \roundnode{s2}(0, 0)  \nodetext{s2}(0, 0){$b$}

  \dirloopedge{s1}{50}(-1, 0) \freetext(-3.6, 0){0}
  \dirbow{s1}{s2}{.2} \bowtext{s1}{s2}{.2}{1}
  \dirbow{s2}{s1}{.2} \bowtext{s2}{s1}{.2}{0}

  \freetext(-2, -0.7){$\Uparrow$}
\end{graph} $(0 + 10)^* (\epsilon + 1)$}
\caption{The Fibonacci automaton}
\label{fig:fibonacci}
\end{figure}
%}}}1

If we take $a$ as the initial letter the substitution gives the following fixed
point:\\
\\
\monoit{u = abaababaabaababaababaabaababaabaababaababaabaababaaba\ldots}\\
\\
The first elements of the language the automaton defines are:

\begin{displaymath}
\mathcal{L}(A) = \{\epsilon, 0, 1, 10, 100, 101, 1000, 1001, 1010, 10000, 
10001, 10010, 10100, \ldots\}
\end{displaymath}
This language has no consecutive ones. We call the $(n + 1)$-th word in this
sequence the Zeckendorf expansion of an integer $n$.

\begin{definition}[The Fibonacci sequence]
Let $(F_n)_{n \in \mathbb{N}}$ be the sequence of integers defined by $F_0 = 1,
F_1 = 2$ and for any integer $n > 1, F_{n + 1} = F_{n - 1} + F_n$.
\end{definition}

\begin{definition}[The Zeckendorf expansion]
If $n = \sum_{i = 0}^k n_i F_i$ with $n_k = 1, n_i \in \{0, 1\}$ and
$\forall (i < k) \{n_i n_{i + 1} = 0\}$, we say that
Zeck$(n) = n_k n_{k - 1} \ldots n_0 \in \{0, 1\}^{k + 1}$ is the Zeckendorf
expansion of the integer $n$.
\end{definition}

If we write the partitions of
$\mathbb{N}$ as $\mathbb{F}_a$ and $\mathbb{F}_b$,
\begin{eqnarray*}
\;\;\;\;\;\;\;\;\;
  \mathbb{F}_a &=& \{0, 2, 3, 5, 7, 8, 10, 11, 13, 15, \ldots\}\\
  \mathbb{F}_b &=& \{1, 4, 6, 9, 12, 14, 17, 19, 22, 25, \ldots\}
\end{eqnarray*}
Then
\begin{eqnarray*}
  \mathbb{F}_a &=& \{n \in \mathbb{N}, \mathrm{Zeck}(n) \in \{0, 1\}^* 0\}\\
  \mathbb{F}_b &=& \{n \in \mathbb{N}, \mathrm{Zeck}(n) \in \{0, 1\}^* 1\}
\end{eqnarray*}
Hence we get an $a$ at position $n$ if $n$ ends with a 0 in the
Zeckendorf expansion, we get an $b$ otherwise.\\
\\
So if we want to calculate the $n$-th word of the language this automaton 
defines, we only have to expand $n$ according to the Zeckendorf algorithm.

\subsection{Fibonacci's `brother'}
In figure: \ref{fig:fibonacci_brother} we see another substitution that is 
semi-automatic.

\begin{example}
% Picture of automaton. {{{1
\begin{figure}[p]
\begin{eqnarray*}
\spaces
\sigma: \left\{ \begin{array}{lll}
a &\rightarrow& ab\\
b &\rightarrow& b
\end{array} \right.
\end{eqnarray*}
\begin{graph}(0, 1)(-4, -1.75)
  \graphnodecolour{1}
  \graphnodesize{1}
  \roundnode{s1}(-2, 0) \nodetext{s1}(0, 0){$a$}
  \roundnode{s2}(0, 0)  \nodetext{s2}(0, 0){$b$}

  \dirloopedge{s1}{50}(-1, 0) \freetext(-3.6, 0){0}
  \diredge{s1}{s2} \edgetext{s1}{s2}{1}
  \dirloopedge{s2}{50}(1, 0) \freetext(1.6, 0){0}

  \freetext(-2, -0.7){$\Uparrow$}
\end{graph} $0^* (\epsilon + 10^*)$
\caption{A Fibonacci-like automaton}
\label{fig:fibonacci_brother}
\end{figure}
%}}}1

The enumeration system for this substitution is based on the sequence 
$n \in \mathbb{N}^+$. So the first few expansions are as follows:
\begin{verbatim}
0 -> 0
1 -> 1
2 -> 10
3 -> 100
4 -> 1000
 ...
\end{verbatim}
\end{example}

\section{A generalization}
Can we find a more general class of automata that have similar properties? The 
answer seems to be yes for a (possibly small) class of substitutions. This 
class can be found by calculating the sequence on which the expansion is based 
from the substitution itself. If we look at the Fibonacci substitution, we see 
that for each word $\sigma_n$:
\begin{eqnarray*}
|\sigma_n|_a &=& |\sigma_{n - 1}|_a + |\sigma_{n - 1}|_b\\
|\sigma_n|_b &=& |\sigma_{n - 1}|_a
\end{eqnarray*}
Or in matrix form:
\begin{displaymath} F = \left( \begin{array}{cc}
1 & 1\\
1 & 0
\end{array} \right) \end{displaymath}
If we now define the initial matrix as:
\begin{displaymath} \left( \begin{array}{c}
1 \\
0 
\end{array} \right) \end{displaymath}
and multiply it repeatedly with the (2 $\times$ 2) matrix $F$, we obtain:
% Row of matrices. {{{1
\begin{displaymath} 
\left( \begin{array}{c}
1 \\
0 
\end{array} \right),
\left( \begin{array}{c}
1 \\
1 
\end{array} \right),
\left( \begin{array}{c}
2 \\
1 
\end{array} \right),
\left( \begin{array}{c}
3 \\
2 
\end{array} \right),
\left( \begin{array}{c}
5 \\
3 
\end{array} \right),
\left( \begin{array}{c}
8 \\
5 
\end{array} \right),
\left( \begin{array}{c}
13 \\
8 
\end{array} \right), \ldots
\end{displaymath}
%}}}1
and if we add the rows of the matrices we obtain the Fibonacci sequence.\\
\\
The matrix for the `brother' of the Fibonacci sequence is
\begin{displaymath} \left( \begin{array}{cc}
1 & 0\\
1 & 1
\end{array} \right), \end{displaymath}
which applied to the initial matrix yields the sequence of integers in 
$\mathbb{N}^+$.

By using this method we find a numeration system for any automaton. And by 
using a greedy generalized Zeckendorf expansion we can cover all $k$-automata, 
the Fibonacci automaton and its `brother'.

\begin{lemma}[Substitutions and numeration systems] \label{lem:subst-numsys}
If we take the incidence matrix of a substitution with a fixed point and
multiply an initial matrix repeatedly with it, we obtain a sequence of matrices
of which the sum of the rows form a numeration system.
\end{lemma}

\begin{proof}
The sum of the resulting matrix after $i$ multiplications is the position in 
the fixed point after having done $i$ substitutions. This is so by definition.
Since no $n$-word in such a substitution scheme has the same length (hence the
existence of a fixed point), the resulting sequence is strictly increasing and
$\mathrm{sup}\frac{U_{n + 1}}{U_n} = \beta$, with $\beta$ the eigenvector of
the incidence matrix.
\end{proof}

Note that this proof also holds for most substitutions that have an infinite
$n$-word, but then the resulting sequence does not need to be strictly 
increasing, only increasing.

\subsection{The expansion algorithm}
From a substitution we can extract a numeration system, but we still need an
expansion algorithm to generate $\mathcal{L}(A)$. 

\paragraph{Automatic expansion}
Let $U$ be a numeration system, let $A$ be an automaton and let $A_i$ be 
the state in which the automaton will be after reading $i$ letters of an 
input word. Let $t(A_i)$ be the set of outgoing transitions of state $A_i$.
If we can write any integer $n \ge 0$ as 
$n = \sum_{i = 0}^k n_i U_i$ with 
$n_k \in \{1, \ldots, k^\mathrm{max} - 1\}$ and $n_i \in t(A_i)$ in a 
unique way such that the automaton accepts the expansion, then Auto($n$) = 
$n_k n_{k - 1} \ldots n_0$ is said to be the automatic expansion of the 
integer $n$.

Since we are only interested in a mapping from $\mathbb{N}^+$ to the regular
language the automaton accepts, it makes sense to look at it this way: does
the automatic expansion of an integer represent the integer itself?

We have devised an algorithm that should answer that question for any
substitution:

\begin{definition}[Automatic expansion]
Let $U_i$ be the largest integer smaller or equal to $n \cdot t(A_0)$. Let 
$n_i$ be the largest element in $t(A_i)$ which is larger or equal to 0 when 
multiplied with $U_i$. Repeat this process $i$ times with $n - n_i$. If we have
0 left when we are done, then we have successfully expanded $n$.
\end{definition}

\begin{example}
% Picture of automaton. {{{1
\begin{figure}[p]
\vbox{
\begin{eqnarray*}
\spaces
\sigma: \left\{ \begin{array}{lll}
a &\rightarrow& aab\\
b &\rightarrow& c\\
c &\rightarrow& aac
\end{array} \right.
\end{eqnarray*}
\begin{graph}(0, 1)(-4, -2)
  \graphnodecolour{1}
  \graphnodesize{1}
  \roundnode{s1}(-2, 0) \nodetext{s1}(0, 0){$a$}
  \roundnode{s2}(0, 0)  \nodetext{s2}(0, 0){$b$}
  \roundnode{s3}(2, 0)  \nodetext{s3}(0, 0){$c$}

  \dirloopedge{s1}{50}(-1, 0) \freetext(-3.6, 0){0, 1}
  \diredge{s1}{s2} \edgetext{s1}{s2}{2}
  \diredge{s2}{s3} \edgetext{s2}{s3}{0}
  \dirbow{s3}{s1}{.3} \bowtext{s3}{s1}{.3}{0, 1}
  \dirloopedge{s3}{50}(1, 0) \freetext(3.6, 0){2}

  \freetext(-2, -0.7){$\Uparrow$}
\end{graph}$(0 + 1 + (202^* (0 + 1)))^* 202^* + 2 + \epsilon$}
\caption{A semi-automatic automaton}
\label{fig:semi1}
\end{figure}
%}}}1
The following numeration system is defined by the substitution defined in
figure \ref{fig:semi1}.
\begin{displaymath}
\{1, 3, 7, 17, 43, 109, 275, 693, 1747, 4405, 11107, \ldots \}
\end{displaymath}
Let us say that we want to expand the decimal number 41.

$U_i = 17$, this makes $i = 3$. The expansion goes as follows:

The first element is 2 because $2 \cdot 17 \le 41$, this leaves 
$41 - (2 \cdot 17) = 7$ to be expanded. Go to state $b$ (follow label 2).

The second element is 0 because this is the only transition going out of 
state $b$. Go to state $c$.

The third element is 2 because $2 \cdot U_1 = 2 \cdot 3 \le 7$, this leaves
$7 - (2 \cdot 3) = 1$ to be expanded. Go to state $c$ (follow label 2).

The last element is 1.
\end{example}

We deliberately took this particular substitution because a generalized 
Zeckendorf expansion does not work in this case.

\section{Survey}
Now we look at which substitutions are semi-automatic. We have already seen 
that the Fibonacci automaton and the $k$-automata have this property.

\paragraph{The extended Fibonacci automata}
Figure \ref{fig:semi2} gives another example of a substitution that is 
semi-automatic.

\begin{example}
% Picture of automaton. {{{1
\begin{figure}[p]
\vbox{
\begin{eqnarray*}
\spaces
\sigma: \left\{ \begin{array}{lll}
a &\rightarrow& ab\\
b &\rightarrow& ac\\
c &\rightarrow& b
\end{array} \right.
\end{eqnarray*}
\begin{graph}(0, 1)(-4, -2)
  \graphnodecolour{1}
  \graphnodesize{1}
  \roundnode{s1}(-2, 0) \nodetext{s1}(0, 0){$a$}
  \roundnode{s2}(0, 0)  \nodetext{s2}(0, 0){$b$}
  \roundnode{s3}(2, 0)  \nodetext{s3}(0, 0){$c$}

  \dirloopedge{s1}{50}(-1, 0) \freetext(-3.6, 0){0}
  \dirbow{s1}{s2}{.2} \bowtext{s1}{s2}{.2}{1}
  \dirbow{s2}{s1}{.2} \bowtext{s2}{s1}{.2}{0}
  \dirbow{s2}{s3}{.2} \bowtext{s2}{s3}{.2}{1}
  \dirbow{s3}{s2}{.2} \bowtext{s3}{s2}{.2}{0}

  \freetext(-2, -0.7){$\Uparrow$}
\end{graph} $(0 + (1 (10)^* 0))^* (\epsilon + (1 (10)^* (\epsilon + 1)))$}
\caption{A semi-automatic automaton}
\label{fig:semi2}
\end{figure}
%}}}1
\end{example}

From figure \ref{fig:semi2} on we will omit the regular expressions because it 
is tedious work and because the automaton gives a more insightful picture of 
the language than the regular expression.\\
\\
Just like the Fibonacci automaton, this one has a couple of `brothers and 
sisters', the most important of them are shown in figures \ref{fig:semi3}, 
\ref{fig:semi4} and \ref{fig:semi5}.

% Picture of automaton. {{{1
\begin{figure}[p]
\vbox{
\begin{eqnarray*}
\spaces
\sigma: \left\{ \begin{array}{lll}
a &\rightarrow& ab\\
b &\rightarrow& ac\\
c &\rightarrow& a
\end{array} \right.
\end{eqnarray*}
\begin{graph}(0, 0)(-4, -1)
  \graphnodecolour{1}
  \graphnodesize{1}
  \roundnode{s1}(-2, 0) \nodetext{s1}(0, 0){$a$}
  \roundnode{s2}(0, 0)  \nodetext{s2}(0, 0){$b$}
  \roundnode{s3}(2, 0)  \nodetext{s3}(0, 0){$c$}

  \dirloopedge{s1}{50}(-1, 0) \freetext(-3.6, 0){0}
  \dirbow{s1}{s2}{.2} \bowtext{s1}{s2}{.2}{1}
  \dirbow{s2}{s1}{.2} \bowtext{s2}{s1}{.2}{0}
  \diredge{s2}{s3} \edgetext{s2}{s3}{1}
  \dirbow{s3}{s1}{.3} \bowtext{s3}{s1}{.3}{0}

  \freetext(-2, -0.7){$\Uparrow$}
\end{graph}}
\caption{A semi-automatic automaton}
\label{fig:semi3}
\end{figure}
%}}}1

% Picture of automaton. {{{1
\begin{figure}[p]
\vbox{
\begin{eqnarray*}
\spaces
\sigma: \left\{ \begin{array}{lll}
a &\rightarrow& ab\\
b &\rightarrow& ac\\
c &\rightarrow& c
\end{array} \right.
\end{eqnarray*}
\begin{graph}(0, 0)(-4, -1)
  \graphnodecolour{1}
  \graphnodesize{1}
  \roundnode{s1}(-2, 0) \nodetext{s1}(0, 0){$a$}
  \roundnode{s2}(0, 0)  \nodetext{s2}(0, 0){$b$}
  \roundnode{s3}(2, 0)  \nodetext{s3}(0, 0){$c$}

  \dirloopedge{s1}{50}(-1, 0) \freetext(-3.6, 0){0}
  \dirbow{s1}{s2}{.2} \bowtext{s1}{s2}{.2}{1}
  \dirbow{s2}{s1}{.2} \bowtext{s2}{s1}{.2}{0}
  \diredge{s2}{s3} \edgetext{s2}{s3}{1}
  \dirloopedge{s3}{50}(1,0) \freetext(3.6, 0){0}

  \freetext(-2, -0.7){$\Uparrow$}
\end{graph}}
\caption{A semi-automatic automaton}
\label{fig:semi4}
\end{figure}
%}}}1

% Picture of automaton. {{{1
\begin{figure}[p]
\vbox{
\begin{eqnarray*}
\spaces
\sigma: \left\{ \begin{array}{lll}
a &\rightarrow& ab\\
b &\rightarrow& c\\
c &\rightarrow& a
\end{array} \right.
\end{eqnarray*}
\begin{graph}(0, 0)(-4, -1)
  \graphnodecolour{1}
  \graphnodesize{1}
  \roundnode{s1}(-2, 0) \nodetext{s1}(0, 0){$a$}
  \roundnode{s2}(0, 0)  \nodetext{s2}(0, 0){$b$}
  \roundnode{s3}(2, 0)  \nodetext{s3}(0, 0){$c$}

  \dirloopedge{s1}{50}(-1, 0) \freetext(-3.6, 0){0}
  \diredge{s1}{s2} \edgetext{s1}{s2}{1}
  \diredge{s2}{s3} \edgetext{s2}{s3}{0}
  \dirbow{s3}{s1}{.3} \bowtext{s3}{s1}{.3}{0}

  \freetext(-2, -0.7){$\Uparrow$}
\end{graph}}
\caption{A semi-automatic automaton}
\label{fig:semi5}
\end{figure}
%}}}1
We can keep adding states as shown in figure \ref{fig:semi6}

% Picture of automaton. {{{1
\begin{figure}[p]
\vbox{
\begin{eqnarray*}
\spaces
\sigma: \left\{ \begin{array}{lll}
a &\rightarrow& ab\\
b &\rightarrow& ac\\
c &\rightarrow& ad\\
d &\rightarrow& c
\end{array} \right.
\end{eqnarray*}
\begin{graph}(0, 0)(-4, -1.3)
  \graphnodecolour{1}
  \graphnodesize{1}
  \roundnode{s1}(-2, 0) \nodetext{s1}(0, 0){$a$}
  \roundnode{s2}(0, 0)  \nodetext{s2}(0, 0){$b$}
  \roundnode{s3}(2, 0)  \nodetext{s3}(0, 0){$c$}
  \roundnode{s4}(4, 0)  \nodetext{s4}(0, 0){$d$}

  \dirloopedge{s1}{50}(-1, 0) \freetext(-3.6, 0){0}
  \dirbow{s1}{s2}{.2} \bowtext{s1}{s2}{.2}{1}
  \dirbow{s2}{s1}{.2} \bowtext{s2}{s1}{.2}{0}
  \diredge{s2}{s3} \edgetext{s2}{s3}{1}
  \dirbow{s3}{s1}{.3} \bowtext{s3}{s1}{.3}{0}
  \dirbow{s3}{s4}{.2} \bowtext{s3}{s4}{.2}{1}
  \dirbow{s4}{s3}{.2} \bowtext{s4}{s3}{.2}{0}

  \freetext(-2, -0.7){$\Uparrow$}
\end{graph}}
\caption{A semi-automatic automaton}
\label{fig:semi6}
\end{figure}
%}}}1
But we can also increase the number of transitions, instead of the number of
states, these sequences look like the one shown in figure \ref{fig:semi7}.

% Picture of automaton. {{{1
\begin{figure}[p]
\vbox{
\begin{eqnarray*}
\spaces
\sigma: \left\{ \begin{array}{lll}
a &\rightarrow& aab\\
b &\rightarrow& aac\\
c &\rightarrow& a
\end{array} \right.
\end{eqnarray*}
\begin{graph}(0, 0)(-4, -1)
  \graphnodecolour{1}
  \graphnodesize{1}
  \roundnode{s1}(-2, 0) \nodetext{s1}(0, 0){$a$}
  \roundnode{s2}(0, 0)  \nodetext{s2}(0, 0){$b$}
  \roundnode{s3}(2, 0)  \nodetext{s3}(0, 0){$c$}

  \dirloopedge{s1}{50}(-1, 0) \freetext(-3.6, 0){0,1}
  \dirbow{s1}{s2}{.2} \bowtext{s1}{s2}{.2}{2}
  \dirbow{s2}{s1}{.2} \bowtext{s2}{s1}{.2}{0,1}
  \diredge{s2}{s3} \edgetext{s2}{s3}{2}
  \dirbow{s3}{s1}{.3} \bowtext{s3}{s1}{.3}{0}

  \freetext(-2, -0.7){$\Uparrow$}
\end{graph}}
\caption{A semi-automatic automaton}
\label{fig:semi7}
\end{figure}
%}}}1

And here we stumble upon a family which all have a matrix of this form:
\begin{displaymath}
\left( \begin{array}{cccccc}
x_{0, 0} & x_{0, 1} & x_{0, 2} & x_{0, 3} & \ldots & x_{0, n}\\
1 & 0 & 0 & 0 & \ldots & x_{1, n}\\
0 & 1 & 0 & 0 & \ldots & x_{2, n}\\
0 & 0 & 1 & 0 & \ldots & x_{3, n}\\
\vdots & \vdots & \vdots & \ddots & \ldots & \vdots\\
0 & 0 & 0 & \ldots & 1 & x_{n, n}
\end{array} \right)
\end{displaymath}
In which $x_{0, 0}$ must be larger or equal to 1, 
$x_{0, 1}, x_{0, 1} \ldots x_{0, n}$ and $x_{1, n}, x_{2, n} \ldots x_{n, n}$ 
may be any value between 0 and $k^\mathrm{max} - 1$.\\
\\
But this is not the only restriction, because the substitution in figure 
\ref{fig:nonsemi} has a valid matrix, but is not semi-automatic:

% Picture of automaton. {{{1
\begin{figure}[p]
\vbox{
\begin{eqnarray*}
\spaces
\sigma: \left\{ \begin{array}{lll}
a &\rightarrow& ab\\
b &\rightarrow& ca\\
c &\rightarrow& a\\
\end{array} \right.
\end{eqnarray*}
\begin{graph}(0, 0)(-4, -1)
  \graphnodecolour{1}
  \graphnodesize{1}
  \roundnode{s1}(-2, 0) \nodetext{s1}(0, 0){$a$}
  \roundnode{s2}(0, 0)  \nodetext{s2}(0, 0){$b$}
  \roundnode{s3}(2, 0)  \nodetext{s3}(0, 0){$c$}

  \dirloopedge{s1}{50}(-1, 0) \freetext(-3.6, 0){0}
  \dirbow{s1}{s2}{.2} \bowtext{s1}{s2}{.2}{1}
  \dirbow{s2}{s1}{.2} \bowtext{s2}{s1}{.2}{1}
  \diredge{s2}{s3} \edgetext{s2}{s3}{0}
  \dirbow{s3}{s1}{.3} \bowtext{s3}{s1}{.3}{0}

  \freetext(-2, -0.7){$\Uparrow$}
\end{graph}}
\caption{A non-semi-automatic automaton}
\label{fig:nonsemi}
\end{figure}
%}}}1

The expansion sequence is as follows:
\begin{displaymath}
\{1, 2, 4, 7, 13, 24, 44, 81, 149, 274, 504, 927, \ldots \}
\end{displaymath}
And the automaton crashes when we try to expand the number 5:
\begin{displaymath}
5_{10} = 101_{\mathrm{auto}}
\end{displaymath}
which has no other expansion.

\begin{conjecture}[A guess] \label{conj:guess}
If the substitution is of this form:
\begin{eqnarray*}
\sigma: \left\{ \begin{array}{lll}
a &\rightarrow& a^+ (\epsilon + b)\\
b &\rightarrow& a^* (\epsilon + b + c)\\
c &\rightarrow& a^* (\epsilon + b + c + d)\\
  &\ldots     &
\end{array} \right.
\end{eqnarray*}
If each production in the substitution scheme is of this form:
\begin{displaymath}
a \rightarrow a^*b, \mathrm{\ with\ } a \in \mathcal{S} 
\mathrm{\ constant\ and\ } b \in \mathcal{S} 
\end{displaymath}
then the associated automaton is semi-automatic.
\end{conjecture}

\section{Combining automata}
The automata described above are `basic' automata, which means that the 
automata define their own numeration system and that the automata are minimal.
We can use these automata as a basis for other automata.\\
\\
Let $\mathcal{A}$ and $\mathcal{B}$ be automata, let $\iota$ be the initial
state of an automaton.
\begin{itemize}
\item Start in the superstate $\{\iota, \iota\}$ and make this state the 
      initial state.
\item If both $\mathcal{A}$ and $\mathcal{B}$ have a transition from $\iota$ 
      labeled $i$, make a new superstate $\{a, b\}$ (the endpoints of the 
      transitions in both automata) and make a new transition from 
      $\{\iota, \iota\}$ to $\{a, b\}$ labeled $i$.
\item Do the same for all other states.
\end{itemize}

\begin{example}
% Picture of Fibonacci-Prouhet-Thue-Morse automaton. {{{1
\begin{figure}[p]
\begin{graph}(0, 3)(-4, -1.5)
  \graphnodecolour{1}
  \graphnodesize{1}
  \roundnode{s1}(-2, 0) \nodetext{s1}(0, 0){$a$}
  \roundnode{s2}(0, 0)  \nodetext{s2}(0, 0){$b$}

  \dirloopedge{s1}{50}(-1, 0) \freetext(-3.6, 0){0}
  \dirbow{s1}{s2}{.2} \bowtext{s1}{s2}{.2}{1}
  \dirbow{s2}{s1}{.2} \bowtext{s2}{s1}{.2}{0}

  \freetext(-2, -0.7){$\Uparrow$}
  \freetext(1, 0){$\times$}
\end{graph}
\begin{graph}(0, 3)(-9, -1.5)
  \graphnodecolour{1}
  \graphnodesize{1}
  \roundnode{s1}(-2, 0) \nodetext{s1}(0, 0){$a$}
  \roundnode{s2}(0, 0)  \nodetext{s2}(0, 0){$b$}

  \dirloopedge{s1}{50}(-1, 0) \freetext(-3.6, 0){0}
  \dirbow{s1}{s2}{.2} \bowtext{s1}{s2}{.2}{1}
  \dirbow{s2}{s1}{.2} \bowtext{s2}{s1}{.2}{1}
  \dirloopedge{s2}{50}(1, 0) \freetext(1.6, 0){0}

  \freetext(-2, -0.7){$\Uparrow$}
\end{graph}

\begin{graph}(0, 4)(-4, -3)
  \graphnodecolour{1}
  \graphnodesize{1}
  \textnode{s1}(-2, -2){$\{a, a\}$}
  \textnode{s2}(0, -2){$\{b, b\}$}
  \textnode{s3}(0, 0){$\{a, b\}$}
  \textnode{s4}(-2, 0){$\{b, a\}$}

  \dirloopedge{s1}{50}(-0.7, -0.7) \freetext(-3.1, -3.1){0}
  \diredge{s1}{s2} \edgetext{s1}{s2}{1}
  \diredge{s2}{s3} \edgetext{s2}{s3}{0}
  \dirloopedge{s3}{50}(0.7, 0.7) \freetext(1.1, 1.1){0}
  \diredge{s3}{s4} \edgetext{s3}{s4}{1}
  \diredge{s4}{s1} \edgetext{s4}{s1}{0}

  \freetext(-1.9, -2.45){$\Uparrow$}
  \freetext(-3, -1){=}
\end{graph}
\begin{graph}(0, 4)(-9, -3)
  \graphnodecolour{1}
  \graphnodesize{1}
  \roundnode{s1}(-2, -2) \nodetext{s1}(0, 0){$a$}
  \roundnode{s2}(0, -2)  \nodetext{s2}(0, 0){$b$}
  \roundnode{s3}(0, 0) \nodetext{s3}(0, 0){$c$}
  \roundnode{s4}(-2, 0)  \nodetext{s4}(0, 0){$d$}

  \dirloopedge{s1}{50}(-0.7, -0.7) \freetext(-3.1, -3.1){0}
  \diredge{s1}{s2} \edgetext{s1}{s2}{1}
  \diredge{s2}{s3} \edgetext{s2}{s3}{0}
  \dirloopedge{s3}{50}(0.7, 0.7) \freetext(1.1, 1.1){0}
  \diredge{s3}{s4} \edgetext{s3}{s4}{1}
  \diredge{s4}{s1} \edgetext{s4}{s1}{0}

  \freetext(-2, -2.7){$\Uparrow$}
  \freetext(-3, -1){=}
\end{graph}
\caption{Combined automata}
\label{fig:combined}
\end{figure}
%}}}1

In figure \ref{fig:combined} we have combined the Fibonacci automaton with the 
Prouhet-Thue-Morse automaton by applying the superset construction to the two 
automata.

The result is an automaton that generates the Prouhet-Thue-Morse sequence in 
the Fibonacci numeration system. By using the following exit map:
\begin{eqnarray*}
\varphi: \left\{ \begin{array}{lll}
a &\rightarrow& a\\
b &\rightarrow& b\\
c &\rightarrow& b\\
d &\rightarrow& a
\end{array} \right.
\end{eqnarray*}
We obtain the Prouhet-Thue-Morse sequence again, and by using this exit map:
\begin{eqnarray*}
\varphi: \left\{ \begin{array}{lll}
a &\rightarrow& a\\
b &\rightarrow& b\\
c &\rightarrow& a\\
d &\rightarrow& b
\end{array} \right.
\end{eqnarray*}
We get the Fibonacci sequence again.
\end{example}

\section{Reverse reading}
We know from the theory of $k$-automata \cite{Fogg}, page 15 that if a 
$k$-automaton in direct reading exists, there also exists a $k$-automaton in 
reverse reading. The proof of this relies upon the existence of a $k$-kernel.

In general we can not make a $k$-kernel, but we can make a similar thing named
a $q$-kernel, which is a $k$-kernel in a particular number system. However, we 
can also construct an automaton in reverse reading from an automaton in direct 
reading without having to construct a kernel first.

We know this is possible because the theory of formal languages \cite{Wood}, 
page 419 state that a regular language is closed under the operation of 
mirroring, but this theory does not give an algorithm to make such an 
automaton. This is because the theory of formal languages does not apply to 
$k$-automata and semi-automata directly. For example, the Prouhet-Thue-Morse 
automaton should be reduced to an automaton with one state and two loops with 
labels 0 and 1 according to this theory. Because this is the minimal automaton 
that accepts $\{0, 1\}^*$. Moreover, all 2-automata should be reduced to this 
automaton.

\paragraph{Reversing an automaton}
To reverse an automaton, we only have to make all final states initial states
and vice versa and we must change the direction of the transitions. By doing 
this, we will most likely end up with a non-deterministic automaton. 
Fortunately, the non-deterministic automaton can be converted to a 
deterministic one using the \emph{subset construction} \cite{Wood}, page 118. 
This construction does not take into account that the final states may have 
partitions.

Analogous we make our automaton in reverse reading, but we do take into account
the possibility of partitions by including the output function in the state.

\begin{example}
We have an automaton shown in figure \ref{fig:det_direct}.
\begin{itemize}
% Picture of automaton in direct reading. {{{1
\begin{figure}[p]
\vbox{
\begin{eqnarray*}
\spaces
\sigma: \left\{ \begin{array}{lll}
a &\rightarrow& ab\\
b &\rightarrow& c\\
c &\rightarrow& cc
\end{array} \right.
\end{eqnarray*}
\begin{graph}(0, 0)(-4, -1)
  \graphnodecolour{1}
  \graphnodesize{1}
  \roundnode{s1}(-2, 0) 
    \nodetext{s1}(0, -0.22){\circle{0.8}} \nodetext{s1}(0, 0){$a$}
  \roundnode{s2}(0, 0)  
    \nodetext{s2}(0, -0.22){\circle{0.8}} \nodetext{s2}(0, 0){$b$}
  \roundnode{s3}(2, 0)  
    \nodetext{s3}(0, -0.22){\circle{0.8}} \nodetext{s3}(0, 0){$c$}

  \dirloopedge{s1}{50}(-1, 0) \freetext(-3.6, 0){0}
  \diredge{s1}{s2} \edgetext{s1}{s2}{1}
  \diredge{s2}{s3} \edgetext{s2}{s3}{0}
  \dirloopedge{s3}{50}(1, 0) \freetext(3.6, 0){0,1}

  \freetext(-2, -0.7){$\Uparrow$}
\end{graph}}
\caption{A deterministic automaton in direct reading}
\label{fig:det_direct}
\end{figure}
%}}}1

\item First we swap final- and inititial states and we change the direction of 
      the transitions shown in figure \ref{fig:nondet_reverse}.

% Picture of non-deterministic automaton in reverse reading. {{{1
\begin{figure}[p]
\begin{graph}(0, 2)(-4, -0.75)
  \graphnodecolour{1}
  \graphnodesize{1}
  \roundnode{s1}(-2, 0) 
    \nodetext{s1}(0, -0.22){\circle{0.8}} \nodetext{s1}(0, 0){$a$}
  \roundnode{s2}(0, 0) \nodetext{s2}(0, 0){$b$}
  \roundnode{s3}(2, 0) \nodetext{s3}(0, 0){$c$}

  \dirloopedge{s1}{50}(-1, 0) \freetext(-3.6, 0){0}
  \diredge{s2}{s1} \edgetext{s1}{s2}{1}
  \diredge{s3}{s2} \edgetext{s2}{s3}{0}
  \dirloopedge{s3}{50}(1, 0) \freetext(3.6, 0){0,1}

  \freetext(-2, -0.7){$\Uparrow$}
  \freetext(0, -0.7){$\Uparrow$}
  \freetext(2, -0.7){$\Uparrow$}
\end{graph}
\caption{A non-deterministic automaton in reverse reading}
\label{fig:nondet_reverse}
\end{figure}
%}}}1

\item At this point, we would normally convert this automaton to a structural 
      normal form $\lambda$-SNF. We shall not do this here because it will 
      introduce some new states, instead we shall apply the subset construction
      on each of the initial states as if we were dealing with three automata. 
      The result of which is shown in figure \ref{fig:det_reverse}.

% Picture of deterministic automaton in reverse reading. {{{1
\begin{figure}[p]
\begin{graph}(12, 8.5)(1, -0.5)
  \graphnodecolour{1}
  \textnode{s1}(6, 7){$\{a\}, \{b\}, \{c\} / a$}

  \textnode{s2}(3, 5){$\{a\}, \varnothing, \{b, c\} / a$}
  \textnode{s3}(9, 5){$\varnothing, \{a\}, \{c\} / b$}

  \textnode{s4}(3, 3){$\varnothing, \varnothing, \{a, c\} / c$}
  \textnode{s5}(7, 3){$\varnothing, \{a\}, \{b, c\} / b$}
  \textnode{s6}(11, 3){$\varnothing, \varnothing, \{c\} / \epsilon$}

  \textnode{s7}(3, 1){$\varnothing, \varnothing, \{a, b, c\} / c$}
  \textnode{s8}(11, 1){$\varnothing, \varnothing, \{b, c\} / \epsilon$}

  \diredge{s1}{s2} \edgetext{s1}{s2}{0}
  \diredge{s1}{s3} \edgetext{s1}{s3}{1}

  \dirloopedge{s2}{50}(-1, 0) \freetext(1.4, 5){0}
  \diredge{s2}{s4} \edgetext{s2}{s4}{1}
  \diredge{s3}{s5} \edgetext{s3}{s5}{0}
  \diredge{s3}{s6} \edgetext{s3}{s6}{1}

  \dirbow{s4}{s7}{.2} \bowtext{s4}{s7}{.2}{0}
  \dirbow{s4}{s6}{-.1} \bowtext{s4}{s6}{-.1}{1}
  \dirloopedge{s5}{50}(0, 1) \freetext(7, 4.6){0}
  \diredge{s5}{s4} \edgetext{s5}{s4}{1}
  \diredge{s6}{s8} \edgetext{s6}{s8}{0}
  \dirloopedge{s6}{50}(1, 0) \freetext(12.6, 3){1}
  
  \dirloopedge{s7}{50}(0, -1) \freetext(3, -0.6){0}
  \dirbow{s7}{s4}{.2} \bowtext{s7}{s4}{.2}{1}
  \dirloopedge{s8}{50}(0, -1) \freetext(11, -0.6){0}
  \dirbow{s8}{s4}{.1} \bowtext{s8}{s4}{.1}{1}

  \freetext(6, 7.45){$\Downarrow$}
\end{graph}
\caption{A deterministic automaton in reverse reading}
\label{fig:det_reverse}
\end{figure}
%}}}1

\item And if we simplify the nodes to standard notation, we get the automaton 
      as shown in figure \ref{fig:simpl_det_reverse}.

% Picture of simplified deterministic automaton in reverse reading. {{{1
\begin{figure}[p]
\begin{graph}(12, 8.5)(0, -0.5)
  \graphnodecolour{1}
  \graphnodesize{1}
  \roundnode{s1}(6, 7)
    \nodetext{s1}(0, -0.22){\circle{0.8}} \nodetext{s1}(0, 0){$a$}

  \roundnode{s2}(3, 5)
    \nodetext{s2}(0, -0.22){\circle{0.8}} \nodetext{s2}(0, 0){$a$}
  \roundnode{s3}(9, 5)
    \nodetext{s3}(0, -0.22){\circle{0.8}} \nodetext{s3}(0, 0){$b$}

  \roundnode{s5}(6, 4)
    \nodetext{s5}(0, -0.22){\circle{0.8}} \nodetext{s5}(0, 0){$b$}

  \roundnode{s4}(3, 3)
    \nodetext{s4}(0, -0.22){\circle{0.8}} \nodetext{s4}(0, 0){$c$}
  \roundnode{s6}(9, 3) \nodetext{s6}(0, 0){$\epsilon$}

  \roundnode{s7}(3, 1)
    \nodetext{s7}(0, -0.22){\circle{0.8}} \nodetext{s7}(0, 0){$c$}
  \roundnode{s8}(9, 1) \nodetext{s8}(0, 0){$\epsilon$}

  \diredge{s1}{s2} \edgetext{s1}{s2}{0}
  \diredge{s1}{s3} \edgetext{s1}{s3}{1}

  \dirloopedge{s2}{50}(-1, 0) \freetext(1.4, 5){0}
  \diredge{s2}{s4} \edgetext{s2}{s4}{1}
  \diredge{s3}{s5} \edgetext{s3}{s5}{0}
  \diredge{s3}{s6} \edgetext{s3}{s6}{1}

  \dirbow{s4}{s7}{.2} \bowtext{s4}{s7}{.2}{0}
  \diredge{s4}{s6} \edgetext{s4}{s6}{1}
  \dirloopedge{s5}{50}(0, 1) \freetext(6, 5.6){0}
  \diredge{s5}{s4} \edgetext{s5}{s4}{1}
  \diredge{s6}{s8} \edgetext{s6}{s8}{0}
  \dirloopedge{s6}{50}(1, 0) \freetext(10.6, 3){1}

  
  \dirloopedge{s7}{50}(0, -1) \freetext(3, -0.6){0}
  \dirbow{s7}{s4}{.2} \bowtext{s7}{s4}{.2}{1}
  \dirloopedge{s8}{50}(0, -1) \freetext(9, -0.6){0}
  \diredge{s8}{s4} \edgetext{s8}{s4}{1}

  \freetext(6, 7.7){$\Downarrow$}
\end{graph}
\caption{A simplified deterministic automaton in reverse reading}
\label{fig:simpl_det_reverse}
\end{figure}
%}}}1
\end{itemize}
\end{example}

\section{Numeration systems}
The class of semi-automatic substitutions has an interesting subclass. To say;
the class that defines a Full numeration system. We believe that this class
is defined like the one in conjecture \ref{conj:guess}, but with as an extra
demand that the cardinality of the images of the substitution may not increase.

\begin{conjecture}[Full-semi-automatism]
If the substitution $\sigma$ is of this form:
\begin{eqnarray*}
\sigma: \left\{ \begin{array}{lll}
a &\rightarrow& a^+ (\epsilon + b)\\
b &\rightarrow& a^* (\epsilon + b + c)\\
c &\rightarrow& a^* (\epsilon + b + c + d)\\
  &\ldots     &
\end{array} \right.
\end{eqnarray*}
With $|\sigma(a)| \ge |\sigma(b)| \ge |\sigma(c)| \ge \ldots$, then the 
associated automaton is full-semi-automatic.
\end{conjecture}

\section{Conclusion}
We have seen that with the automatic expansion we can successfully find 
numeration systems for a number of automata. The most important findings are
that the substitution defines a numeration system and that the automaton 
defines an expansion algorithm. Combine them and we get the class of 
semi-automatic sequences.

The sequences which are not semi-automatic are still interesting, because
the associated automaton still calculates most of the letters in the fixed
point correctly, but it leaves gaps.
Maybe we can somehow `repair' the automaton to correct this behavior, 
perhaps even by using a stack automaton, but this is (we think) beyond the
scope of this document.

\begin{thebibliography}{XX}
\bibitem{Fogg} Fogg, N. Pytheas. Substitutions is Dynamics, Arithmetics and
               Combinatorics, Springer Verlag, 2002.
\bibitem{Wood} Wood, Derick. Theory of Computation, John Wiley \& sons, inc, 
               1987
\end{thebibliography}

\end{document}
