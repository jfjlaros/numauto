\documentclass{article}
\usepackage{/home/jeroen/studie/dw/graphs/graphs}
\usepackage{amsfonts, amssymb}
\frenchspacing
\begin{document}

\newcommand{\qed}{$\blacksquare$}

\section*{Introduction}
The Fibonacci substitution caught our interest because it defines an 
enumeration system and we wondered if there are other substitutions have the
same property. It seems that there is at least one class of substitutions
for which this property holds.
\paragraph{Definitions}
Since we're discussing non-$k$-automata here, it seems relevant to give a
few definitions on regular languages.
\paragraph{Regular language}
A language is regular if and only if it is accepted by a finite automaton.
\paragraph{Regular expression}
Let $\Sigma$ be an alphabet. Then a regular expression $E$ over $\Sigma$ is
defined recursively as one of the following types:\\
1) $\varnothing$.\\
2) $\epsilon$.\\
3) $a$, where $a \in \Sigma$.\\
4) $(E_1 \cup E_2)$, where $E_1$ and $E_2$ are regular expressions.\\
5) $(E_1 \cdot E_2)$, where $E_1$ and $E_2$ are regular expressions.\\
6) $E^*$, where $E$ is a regular expression.\\
\\
We usually ommit the $\cdot$ in a regular expression. The $\cup$ is sometimes
written as + or , and we use $E^+$ as an abbreviation for $E \cdot E^*$.

\section*{The Fibonacci substitution}
The Fibonacci substitution:
\begin{eqnarray*}
\sigma: \left\{ \begin{array}{lll}
a &\rightarrow& ab\\
b &\rightarrow& a
\end{array} \right.
\end{eqnarray*}
With $a$ as the initial letter gives the following fixed point:
\begin{verbatim}
  u = abaababaabaababaababaabaababaabaababaababaabaababaaba...
\end{verbatim}
This is the automaton associated with the substitution:\\
\begin{graph}(0, 3)(-4, -1.5)
  \graphnodecolour{1}
  \graphnodesize{1}
  \roundnode{s1}(-2, 0) \nodetext{s1}(0, 0){$a$}
  \roundnode{s2}(0, 0)  \nodetext{s2}(0, 0){$b$}

  \dirloopedge{s1}{50}(-1, 0) \freetext(-3.6, 0){0}
  \dirbow{s1}{s2}{.2} \bowtext{s1}{s2}{.2}{1}
  \dirbow{s2}{s1}{.2} \bowtext{s2}{s1}{.2}{0}

  \freetext(-2, -0.7){$\Uparrow$}
\end{graph} $(\epsilon + 1)(0 + 10)^*$\\
\\
To make this automaton work, we need to feed it with the Zeckendorf expansion
of an integer $n$ to get the $n$-th letter of the fixed point.
\paragraph{The Fibonacci sequence}
Let $(F_n)_{n \in \mathbb{N}}$ be the sequence of integers defined by $F_0 = 1,
F_1 = 2$ and for any integer $n > 1, F_{n + 1} = F_{n - 1} + F_n$.
\paragraph{The Zeckendorf expansion}
If $n = \sum_{i = 0}^k n_i F_i$ with $n_k = 1, n_i \in \{0, 1\}$ and
$\forall (i < k) \{n_i n_{i + 1} = 0\}$, we say that
Zeck$(n) = n_k n_{k - 1} ... n_0 \in \{0, 1\}^{k + 1}$ is the Zeckendorf
expansion of the integer $n$.\\
\\
If we write the partitions of
$\mathbb{F}$ as $\mathbb{F}_a$ and $\mathbb{F}_b$,
\begin{eqnarray*}
  \mathbb{F}_a &=& \{0, 2, 3, 5, 7, 8, 10, 11, 13, 15, ...\}\\
  \mathbb{F}_b &=& \{1, 4, 6, 9, 12, 14, 17, 19, 22, 25, ...\}
\end{eqnarray*}
Then
\begin{eqnarray*}
  \mathbb{F}_a &=& \{n \in \mathbb{N}, \mathrm{Zeck}(n) \in \{0, 1\}^* 0\}\\
  \mathbb{F}_b &=& \{n \in \mathbb{N}, \mathrm{Zeck}(n) \in \{0, 1\}^* 1\}
\end{eqnarray*}
Hence we get an $a$ at position $n$ if $n$ ends with a 0 in the
Zeckendorf expansion, we get an $b$ otherwise.

\paragraph{Fibonacci's `brother'}
Here is a little example of an other substitution that is `automatic':
\begin{eqnarray*}
\sigma: \left\{ \begin{array}{lll}
a &\rightarrow& ab\\
b &\rightarrow& b
\end{array} \right.
\end{eqnarray*}
\begin{graph}(0, 3)(-4, -1.5)
  \graphnodecolour{1}
  \graphnodesize{1}
  \roundnode{s1}(-2, 0) \nodetext{s1}(0, 0){$a$}
  \roundnode{s2}(0, 0)  \nodetext{s2}(0, 0){$b$}

  \dirloopedge{s1}{50}(-1, 0) \freetext(-3.6, 0){0}
  \diredge{s1}{s2} \edgetext{s1}{s2}{1}
  \dirloopedge{s2}{50}(1, 0) \freetext(1.6, 0){0}

  \freetext(-2, -0.7){$\Uparrow$}
\end{graph} $0^* (\epsilon + 10^*)$\\
\\
The enumeration system for this substitution is based on the sequence 
$n \in \mathbb{N}^+$. So the first few expansions are as follows:
\begin{verbatim}
0 -> 0
1 -> 1
2 -> 10
3 -> 100
4 -> 1000
 ...
\end{verbatim}

\section*{A generalization}
But can we find a more general way for this phenomenon? The answer seems to
be yes for a (possibly small) class of substitutions. This class can be found
by calculating the sequence on which the expansion is based from the 
substitution itself. If we look at the Fibonacci substitution, we see that for
each word $\sigma_n$:
\begin{eqnarray*}
|\sigma_n|_a &=& |\sigma_{n - 1}|_a + |\sigma_{n - 1}|_b\\
|\sigma_n|_b &=& |\sigma_{n - 1}|_a
\end{eqnarray*}
Or in matrix form:
\begin{displaymath} \left( \begin{array}{cc}
1 & 1\\
1 & 0
\end{array} \right) \end{displaymath}
If we now define the initial matrix as:
\begin{displaymath} \left( \begin{array}{c}
1 \\
0 
\end{array} \right) \end{displaymath}
and multiply it repeatedly with the (2 $\times$ 2) matrix, we obtain:
\begin{displaymath} 
\left( \begin{array}{c}
1 \\
0 
\end{array} \right),
\left( \begin{array}{c}
1 \\
1 
\end{array} \right),
\left( \begin{array}{c}
2 \\
1 
\end{array} \right),
\left( \begin{array}{c}
3 \\
2 
\end{array} \right),
\left( \begin{array}{c}
5 \\
3 
\end{array} \right),
\left( \begin{array}{c}
8 \\
5 
\end{array} \right),
\left( \begin{array}{c}
13 \\
8 
\end{array} \right)
\end{displaymath}
And if we now add the rows of the matrices we obtain the Fibonacci sequence.\\
\\
The matrix for the `brother' of the Fibonacci sequence is:
\begin{displaymath} \left( \begin{array}{cc}
1 & 0\\
1 & 1
\end{array} \right) \end{displaymath}
Which applied to the initial matrix yields the sequence of integers in $\mathbb{N}^+$.\\
By using this method we can cover all $k$-automata, the Fibonacci automaton and
its `brother', which appear to be part of a larger class of automata.

\paragraph{General Zeckendorf expansion}
Note that we need to define a more general Zeckendorf-like expansion to make
the automata work. It seems that a simple greedy algorithm works fine in most
cases:\\
Let $S$ be a sequence obtained from the method described above. We observe
that a sequence like this is increasing and grows at most as fast as $k^n$.\\
If $n = \sum_{i = 0}^k n_i S_i$ with $0 < n_k < k$ and 
$\forall (i < k) \{0 \le n_i < k\}$, we say that 
$n_k n_{k - 1} ... n_0$ is the expansion of $n$ in the $S$ enumeration system.

\section*{Survey}
Now we look at which substitutions are `automatic' in their own enumeration
system. We have already seen that the Fibonacci automaton and the $k$-automata
have this property.

\paragraph{The extended Fibonacci automata}
Here is an example of an other substitution that is automatic in its own
enumeration system:
\begin{eqnarray*}
\sigma: \left\{ \begin{array}{lll}
a &\rightarrow& ab\\
b &\rightarrow& ac\\
c &\rightarrow& b
\end{array} \right.
\end{eqnarray*}
This is the automaton associated with the substitution:\\
\begin{graph}(0, 3)(-4, -1.5)
  \graphnodecolour{1}
  \graphnodesize{1}
  \roundnode{s1}(-2, 0) \nodetext{s1}(0, 0){$a$}
  \roundnode{s2}(0, 0)  \nodetext{s2}(0, 0){$b$}
  \roundnode{s3}(2, 0)  \nodetext{s3}(0, 0){$c$}

  \dirloopedge{s1}{50}(-1, 0) \freetext(-3.6, 0){0}
  \dirbow{s1}{s2}{.2} \bowtext{s1}{s2}{.2}{1}
  \dirbow{s2}{s1}{.2} \bowtext{s2}{s1}{.2}{0}
  \dirbow{s2}{s3}{.2} \bowtext{s2}{s3}{.2}{1}
  \dirbow{s3}{s2}{.2} \bowtext{s3}{s2}{.2}{0}

  \freetext(-2, -0.7){$\Uparrow$}
\end{graph} $(0 + (1 (10)^* 0))^* (\epsilon + (1 (10)^* (\epsilon + 1)))$
\footnote{From here on we will omit the regular expressions because it is 
tedious work and because the automaton gives a more insightful picture of the
language than the regular expression.}\\
\\
Just like the Fibonacci automaton, this one has a couple of `brothers and 
sisters':\\
\begin{graph}(0, 3)(-4, -1.5)
  \graphnodecolour{1}
  \graphnodesize{1}
  \roundnode{s1}(-2, 0) \nodetext{s1}(0, 0){$a$}
  \roundnode{s2}(0, 0)  \nodetext{s2}(0, 0){$b$}
  \roundnode{s3}(2, 0)  \nodetext{s3}(0, 0){$c$}

  \dirloopedge{s1}{50}(-1, 0) \freetext(-3.6, 0){0}
  \dirbow{s1}{s2}{.2} \bowtext{s1}{s2}{.2}{1}
  \dirbow{s2}{s1}{.2} \bowtext{s2}{s1}{.2}{0}
  \diredge{s2}{s3} \edgetext{s2}{s3}{1}
  \dirbow{s3}{s1}{.3} \bowtext{s3}{s1}{.3}{0}

  \freetext(-2, -0.7){$\Uparrow$}
\end{graph}\\
And:\\
\begin{graph}(0, 3)(-4, -1.5)
  \graphnodecolour{1}
  \graphnodesize{1}
  \roundnode{s1}(-2, 0) \nodetext{s1}(0, 0){$a$}
  \roundnode{s2}(0, 0)  \nodetext{s2}(0, 0){$b$}
  \roundnode{s3}(2, 0)  \nodetext{s3}(0, 0){$c$}

  \dirloopedge{s1}{50}(-1, 0) \freetext(-3.6, 0){0}
  \dirbow{s1}{s2}{.2} \bowtext{s1}{s2}{.2}{1}
  \dirbow{s2}{s1}{.2} \bowtext{s2}{s1}{.2}{0}
  \diredge{s2}{s3} \edgetext{s2}{s3}{1}
  \dirloopedge{s3}{50}(1,0) \freetext(3.6, 0){0}

  \freetext(-2, -0.7){$\Uparrow$}
\end{graph}\\
The same seems to hold for the following substitution:
\begin{eqnarray*}
\sigma: \left\{ \begin{array}{lll}
a &\rightarrow& ab\\
b &\rightarrow& ac\\
c &\rightarrow& ad\\
d &\rightarrow& c
\end{array} \right.
\end{eqnarray*}
And also for its `family', which has four members.\\
\\
But we can also increase the number of transitions, instead of the number of
states, these sequences look like this:\\
\begin{eqnarray*}
\sigma: \left\{ \begin{array}{lll}
a &\rightarrow& aab\\
b &\rightarrow& aa\\
\end{array} \right.
\end{eqnarray*}
(There are two of those, $b$ may also go to $ab$). And:
\begin{eqnarray*}
\sigma: \left\{ \begin{array}{lll}
a &\rightarrow& aab\\
b &\rightarrow& aac\\
c &\rightarrow& a
\end{array} \right.
\end{eqnarray*}
And this is the automaton associated with the last substitution:\\
\begin{graph}(0, 3)(-4, -1.5)
  \graphnodecolour{1}
  \graphnodesize{1}
  \roundnode{s1}(-2, 0) \nodetext{s1}(0, 0){$a$}
  \roundnode{s2}(0, 0)  \nodetext{s2}(0, 0){$b$}
  \roundnode{s3}(2, 0)  \nodetext{s3}(0, 0){$c$}

  \dirloopedge{s1}{50}(-1, 0) \freetext(-3.6, 0){0,1}
  \dirbow{s1}{s2}{.2} \bowtext{s1}{s2}{.2}{2}
  \dirbow{s2}{s1}{.2} \bowtext{s2}{s1}{.2}{0,1}
  \diredge{s2}{s3} \edgetext{s2}{s3}{2}
  \dirbow{s3}{s1}{.3} \bowtext{s3}{s1}{.3}{0}

  \freetext(-2, -0.7){$\Uparrow$}
\end{graph}\\
And here we stumble upon a family which all have a matrix of this form:
\begin{displaymath}
\left( \begin{array}{cccccc}
x_{0, 0} & x_{0, 1} & x_{0, 2} & x_{0, 3} & \ldots & x_{0, n}\\
1 & 0 & 0 & 0 & \ldots & x_{1, n}\\
0 & 1 & 0 & 0 & \ldots & x_{2, n}\\
0 & 0 & 1 & 0 & \ldots & x_{3, n}\\
\vdots & \vdots & \vdots & \ddots & \ldots & \vdots\\
0 & 0 & 0 & \ldots & 1 & x_{n, n}
\end{array} \right)
\end{displaymath}
In which $x_{0, 0}$ must be larger or equal to 1, 
$x_{0, 1}, x_{0, 1}... x_{0, n}$ and $x_{1, n}, x_{2, n}... x_{n, n}$ may 
be any value between 0 and $k - 1$.\\
\\
But this is not the only restriction, because the following substitution has
a valid matrix, but is not automatic:
\begin{eqnarray*}
\sigma: \left\{ \begin{array}{lll}
a &\rightarrow& ab\\
b &\rightarrow& ca\\
c &\rightarrow& a\\
\end{array} \right.
\end{eqnarray*}
The expansion sequence is as follows:
\begin{displaymath}
\{1, 2, 4, 7, 13, 24, 44, 81, 149, 274, 504, 927, ... \}
\end{displaymath}
And the automaton looks like this:\\
\begin{graph}(0, 3)(-4, -1.5)
  \graphnodecolour{1}
  \graphnodesize{1}
  \roundnode{s1}(-2, 0) \nodetext{s1}(0, 0){$a$}
  \roundnode{s2}(0, 0)  \nodetext{s2}(0, 0){$b$}
  \roundnode{s3}(2, 0)  \nodetext{s3}(0, 0){$c$}

  \dirloopedge{s1}{50}(-1, 0) \freetext(-3.6, 0){0}
  \dirbow{s1}{s2}{.2} \bowtext{s1}{s2}{.2}{1}
  \dirbow{s2}{s1}{.2} \bowtext{s2}{s1}{.2}{1}
  \diredge{s2}{s3} \edgetext{s2}{s3}{0}
  \dirbow{s3}{s1}{.3} \bowtext{s3}{s1}{.3}{0}

  \freetext(-2, -0.7){$\Uparrow$}
\end{graph}\\
And it crashes when we try to expand the number 5:
\begin{displaymath}
5_{10} = 101_{\mathrm{subst}}
\end{displaymath}
which has no other expansion.

\paragraph{A guess}
If the substitution is of this form:
\begin{eqnarray*}
\sigma: \left\{ \begin{array}{lll}
a &\rightarrow& a^+ b\\
b &\rightarrow& a^* (a + b + c)\\
c &\rightarrow& a^* (a + b + c + d)\\
  &...&
\end{array} \right.
\end{eqnarray*}
then the associated automaton is automatic in its own enumeration system.

\section*{Problems}
Here is a problem that sometimes occurs when we use the greedy approach, we
could stumble upon a substitution that is automatic, but its automaton does
not accept the language we construct. This is the result of the way our
expansion works. Here is an example:
\begin{eqnarray*}
\sigma: \left\{ \begin{array}{lll}
a &\rightarrow& aab\\
b &\rightarrow& c\\
c &\rightarrow& aab
\end{array} \right.
\end{eqnarray*}
This is an automatic sequence and so should the following one be:
\begin{eqnarray*}
\sigma: \left\{ \begin{array}{lll}
a &\rightarrow& aab\\
b &\rightarrow& c\\
c &\rightarrow& aac
\end{array} \right.
\end{eqnarray*}
The following expansion sequence is used for the enumeration system:
\begin{displaymath}
\{1, 3, 7, 17, 43, 109, 275, 693, 1747, 4405, 11107, ... \}
\end{displaymath}
But the first problem we encounter is when we try to calculate the 41-th
letter of the fixed point:
\begin{displaymath}
41_{10} = 2100_{\mathrm{subst}}
\end{displaymath}
which is not accepted by our automaton, but there is another expansion of
41, to say:
\begin{displaymath}
41_{10} = 2021_{\mathrm{subst}}
\end{displaymath}
So how do we know which expansion to take? The answer is: use the automaton
itself; if it rejects an input word, try the next expansion until the
automaton accepts it or until there are no more expansions.\\
\\
We think that if we are dealing with an automatic sequence, we will find a 
valid expansion before we run out of them. Moreover: the automaton should only 
accept only one expansion if it has more than one representation. In any case, 
there seems to be an elegant way to work around this problem. All we need to 
do is walking through the automaton while expanding an integer, if we want to 
expand the next `digit', we can ony use the labels of the outgoing transitions.

\paragraph{Automatic expansion}
Let $S$ be an expansion sequence, let $A$ be an automaton and let $A_i$ be 
the state in which the automaton will be after reading $i$ letters of an 
input word. Let $t(A_i)$ be the set of outgoing transitions of state $A_i$.
If we can write any integer $n \ge 0$ as $n = \sum_{i = 0}^k n_i S_i$ with 
$n_k \in \{0, 1, ..., k - 1\}$ and $n_i \in t(A_i)$ in a unique way such that 
the automaton accepts the expansion, then Auto($n$) = 
$n_k n_{k - 1} ... n_0 \in \{0, 1, ..., k - 1\}^{k + 1}$ is said to be the
automatic expansion of the integer $n$.\\
Since we are only interested in a mapping from $\mathbb{N}^+$ to the regular
language the automaton accepts, it makes sense to look at it this way: does
the automatic expansion of an integer represent the integer itself?\\
We have devised an algorithm that should answer that question for any
substitution:\\
Let $S_i$ be the largest integer smaller or equal to $n \cdot t(A_0)$. Let 
$n_i$ be the largest element in $t(A_i)$ which is larger or equal to 0 when 
multiplied with $S_i$. Repeat this process $i$ times with $n - n_i$. If we have
0 left when we are done, then we have successfully expanded $n$.\\
\\
Here is an example of a non-automatic sequence:
\begin{eqnarray*}
\sigma: \left\{ \begin{array}{lll}
a &\rightarrow& ab\\
b &\rightarrow& ac\\
c &\rightarrow& bd\\
d &\rightarrow& c
\end{array} \right.
\end{eqnarray*}
The expansion sequence is:
\begin{displaymath}
\{1, 2, 4, 8, 15, 29, 54, 103, 192, 364, 680, 1285, 2405, 4536, 8501, ... \}
\end{displaymath}
And we run into trouble when we hit 51:
\begin{displaymath}
51_{10} = 110111_{\mathrm{subst}}
\end{displaymath}
And there is no other expansion possible.\\
\\
We took this example because we can probably see that a substitution is not
automatic (the 1 in the second row, third column should be 0):
\begin{displaymath}
\sigma: \left( \begin{array}{cccc}
1 & 1 & 0 & 0 \\
1 & 0 & 1 & 0 \\
0 & 1 & 0 & 1 \\
0 & 0 & 1 & 0
\end{array} \right)
\end{displaymath}
The sequences for which the matrix are not valid are still interesting, because
the associated automaton still calculates most of the letters in the fixed
point correctly, but it leaves gaps.
Maybe we can somehow `repair' the automaton to correct this behaviour, 
perhaps even by using a stack automaton, but this is (we think) beyond the
scope of this document.

\section*{Important notes}
As you have seen this document lacks all proof, so everything stated above
is pure conjecture. We have used a specially developed utility to check the
automaticity for various substitutions, so we are not entirely sure that
this method is even valid, though it seems acceptable at this time.

%\section*{Proofs in progress}
%\paragraph{Theorem} By using the greedy algorithm we shall always find an
%enumeration system.
%\paragraph{Proof}
%\paragraph{Theorem} The substitutions of the form described above will 
%always be automatic in their own number system.
%\paragraph{Proof}
%\paragraph{Theorem} All automatic substitutions are of the class described
%above.
%\paragraph{Proof} At least the borderpoints are in this class...
%\paragraph{Theorem}
%\paragraph{Proof}
\end{document}
