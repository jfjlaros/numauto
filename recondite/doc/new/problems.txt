The first problem that arises when we use the greedy approach is that we
could stumble upon a substitution that is automatic, but its automaton does 
not accept all the language we construct. This is the result of the way our
expansion works. Here is an example:
a -> aab
b -> c
c -> aab
This is an automatic sequence and so should the following one be:
a -> aab
b -> c
c -> aac

The following expansion sequence is used for the enumeration system:
1 3 7 17 43 109 275 693 1747 4405 11107

But the first problem we encounter is when we try to calculate the 41-th
letter of the fixed point:
41 = 2100
which is not accepted by our automaton, but there is another expansion of
41, to say:
41 = 2021

So how do we know which expansion to take? The answer is: use the automaton 
itself; if it rejects an input word, try the next expansion until the 
automaton accepts it or until there are no more expansions.

We conjecture that if we are dealing with an automatic expansion, we will
find a valid expansion before we run out of them.
Moreover: the automaton should only accept only one expansion if it has more 
than one representation.
We also suspect that there are at most two (or possibly k) possible expansions
of an integer.
In any case, there seems to be an elegant way to work around this problem.
All we need to do is walking through the automaton while expanding an integer,
if we want to expand the next `digit', we can ony use the labels of the 
outgoing transitions. This *should* always give the correct expansion.

Here is an example of a non-automatic sequence:
a -> ab
b -> ac
c -> bd
d -> c

The expansion sequence is:
1 2 4 8 15 29 54 103 192 364 680 1285 2405 4536 8501

And we run into trouble when we hit 51:
51 = 110111

And there is no other expansion possible.

We took this example because we can probably see that a substitution is not
automatic (the 1 in the second row, third column should be 0):
1 1 0 0 
1 0 1 0 
0 1 0 1 
0 0 1 0 

The sequences for which the matrix are not valid are still interesting, because
the associated automaton still calculates most of the letters in the fixed 
point correctly, but it leaves gaps. 
Maybe we can somehow `repair' the automaton to correct this behaviour, but
this is (we think) beyond the scope of this document.
